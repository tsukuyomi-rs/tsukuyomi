//! Components for the basic mechanisim for HTTP/1.1 server upgrade.
//!
//! # Examples
//!
//! ```
//! # extern crate tsukuyomi;
//! # extern crate futures;
//! # extern crate http;
//! # use tsukuyomi::error::Error;
//! # use tsukuyomi::input::Input;
//! # use tsukuyomi::input::upgrade::{Upgraded, UpgradeContext};
//! # use tsukuyomi::output::{Output, ResponseBody};
//! # use futures::{future, Future};
//! # use http::{header, StatusCode, Response};
//! fn validate(input: &Input) -> Result<(), Error> {
//!     // do some stuff ...
//! #   Ok(())
//! }
//!
//! fn on_upgrade(io: Upgraded, cx: UpgradeContext)
//!     -> impl Future<Item = (), Error = ()> + Send + 'static {
//!     // ...
//! #   future::ok(())
//! }
//!
//! fn handshake(input: &mut Input) -> Result<Output, Error> {
//!     validate(input)?;
//!
//!     // Register a callback function called when upgrading
//!     // the server protocol.
//!     let _ = input.body_mut().on_upgrade(on_upgrade);
//!
//!     // Build the handshake response.
//!     // If the status code is set to `101 Switching Protocols`,
//!     // a task will be generated by calling a callback function
//!     // registered at the above section at the end of handling
//!     // the request.
//!     Ok(Response::builder()
//!         .status(StatusCode::SWITCHING_PROTOCOLS)
//!         .header(header::UPGRADE, "foo")
//!         .body(ResponseBody::empty())
//!         .unwrap())
//! }
//! ```

use futures::{Future, IntoFuture};
use http::Request;
pub use hyper::upgrade::Upgraded;

use app::{App, RouteId};
use recognizer::Captures;

use super::local_map::LocalMap;

/// Contextual information used at upgrading to another protocol.
#[derive(Debug)]
pub struct UpgradeContext {
    pub(crate) request: Request<()>,
    pub(crate) app: App,
    pub(crate) locals: LocalMap,
    pub(crate) route: RouteId,
    pub(crate) captures: Captures,
}

impl UpgradeContext {
    /// Returns the reference to a `Request<()>` used during the handshake.
    pub fn request(&self) -> &Request<()> {
        &self.request
    }

    /// Returns the reference to a `LocalMap` used during the handshake.
    pub fn locals(&self) -> &LocalMap {
        &self.locals
    }

    /// Returns the reference to a value of `T` registered in the global storage.
    pub fn get<T>(&self) -> Option<&T>
    where
        T: Send + Sync + 'static,
    {
        self.app.get_state(self.route)
    }
}

/// A trait representing a function called at performing the protocol upgrade.
pub trait OnUpgrade: Send + 'static {
    /// Creates a task for processing the upgraded protocol from the specified context.
    fn on_upgrade(
        self,
        io: Upgraded,
        cx: UpgradeContext,
    ) -> Box<dyn Future<Item = (), Error = ()> + Send + 'static>;
}

impl<F, R> OnUpgrade for F
where
    F: FnOnce(Upgraded, UpgradeContext) -> R + Send + 'static,
    R: IntoFuture<Item = (), Error = ()>,
    R::Future: Send + 'static,
{
    fn on_upgrade(
        self,
        io: Upgraded,
        cx: UpgradeContext,
    ) -> Box<dyn Future<Item = (), Error = ()> + Send + 'static> {
        Box::new((self)(io, cx).into_future())
    }
}

pub(crate) struct OnUpgradeObj(
    Box<
        dyn FnMut(Upgraded, UpgradeContext) -> Box<dyn Future<Item = (), Error = ()> + Send>
            + Send
            + 'static,
    >,
);

impl OnUpgradeObj {
    pub(crate) fn new<T: OnUpgrade>(on_upgrade: T) -> Self {
        let mut on_upgrade = Some(on_upgrade);
        OnUpgradeObj(Box::new(move |io, cx| {
            let on_upgrade = on_upgrade.take().unwrap();
            on_upgrade.on_upgrade(io, cx)
        }))
    }

    pub(crate) fn upgrade(
        mut self,
        io: Upgraded,
        cx: UpgradeContext,
    ) -> Box<dyn Future<Item = (), Error = ()> + Send + 'static> {
        (self.0)(io, cx)
    }
}
