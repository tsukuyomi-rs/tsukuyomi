<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `graphql_object` macro in crate `juniper`."><meta name="keywords" content="rust, rustlang, rust-lang, graphql_object"><title>juniper::graphql_object - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc macro"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><div class="sidebar-elems"><p class='location'><a href='index.html'>juniper</a></p><script>window.sidebarCurrent = {name: 'graphql_object', ty: 'macro', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/juniper/macros/object.rs.html#314-529' title='goto source code'>[src]</a></span><span class='in-band'>Macro <a href='index.html'>juniper</a>::<wbr><a class="macro" href=''>graphql_object</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><div class="example-wrap"><pre class="rust macro">
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">graphql_object</span> {
    (
        @<span class="ident">generate</span>,
        <span class="ident">meta</span> <span class="op">=</span> {
            <span class="ident">lifetimes</span> <span class="op">=</span> [$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">lifetimes</span>:<span class="ident">tt</span>,)<span class="kw-2">*</span>],
            <span class="ident">name</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">name</span>: <span class="ident">ty</span>,
            <span class="ident">ctx</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ctx</span>: <span class="ident">ty</span>,
            <span class="ident">main_self</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">main_self</span>: <span class="ident">ident</span>,
            <span class="ident">outname</span> <span class="op">=</span> {$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">outname</span>: <span class="ident">tt</span>)<span class="kw-2">*</span>},
            <span class="ident">scalar</span> <span class="op">=</span> {$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">scalar</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>},
            $(<span class="ident">description</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">desciption</span>: <span class="ident">expr</span>,)<span class="op">*</span>
            $(<span class="ident">additional</span> <span class="op">=</span> {
                $(<span class="ident">interfaces</span> <span class="op">=</span> [$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">interface</span>:<span class="ident">ty</span>,)<span class="kw-2">*</span>],)<span class="op">*</span>
            },)<span class="op">*</span>
        },
        <span class="ident">items</span> <span class="op">=</span> [$({
            <span class="ident">name</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">fn_name</span>: <span class="ident">ident</span>,
            <span class="ident">body</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>: <span class="ident">block</span>,
            <span class="ident">return_ty</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">return_ty</span>: <span class="ident">ty</span>,
            <span class="ident">args</span> <span class="op">=</span> [$({
                <span class="ident">arg_name</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">arg_name</span> : <span class="ident">ident</span>,
                <span class="ident">arg_ty</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">arg_ty</span>: <span class="ident">ty</span>,
                $(<span class="ident">arg_default</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">arg_default</span>: <span class="ident">expr</span>,)<span class="op">*</span>
                $(<span class="ident">arg_description</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">arg_description</span>: <span class="ident">expr</span>,)<span class="op">*</span>
                $(<span class="ident">arg_docstring</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">arg_docstring</span>: <span class="ident">expr</span>,)<span class="op">*</span>
            },)<span class="kw-2">*</span>],
            $(<span class="ident">decs</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">fn_description</span>: <span class="ident">expr</span>,)<span class="op">*</span>
            $(<span class="ident">docstring</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">docstring</span>: <span class="ident">expr</span>,)<span class="op">*</span>
            $(<span class="ident">deprecated</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">deprecated</span>: <span class="ident">expr</span>,)<span class="op">*</span>
            $(<span class="ident">executor_var</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">executor</span>: <span class="ident">ident</span>,)<span class="op">*</span>
        },)<span class="kw-2">*</span>],
    ) <span class="op">=&gt;</span> { ... };
    (
        @<span class="ident">parse_interfaces</span>,
        <span class="ident">success_callback</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">success_callback</span>: <span class="ident">ident</span>,
        <span class="ident">additional_parser</span> <span class="op">=</span> {$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">additional</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>},
        <span class="ident">meta</span> <span class="op">=</span> {
            <span class="ident">lifetimes</span> <span class="op">=</span> [$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">lifetime</span>:<span class="ident">tt</span>,)<span class="kw-2">*</span>],
            <span class="ident">name</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">name</span>:<span class="ident">ty</span>,
            <span class="ident">ctx</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ctxt</span>: <span class="ident">ty</span>,
            <span class="ident">main_self</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">mainself</span>: <span class="ident">ident</span>,
            <span class="ident">outname</span> <span class="op">=</span> {$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">outname</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>},
            <span class="ident">scalar</span> <span class="op">=</span> {$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">scalar</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>},
            $(<span class="ident">description</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">desciption</span>: <span class="ident">tt</span>,)<span class="op">*</span>
            $(<span class="ident">additional</span> <span class="op">=</span> {
                $(<span class="ident">interfaces</span> <span class="op">=</span> [$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">_interface</span>:<span class="ident">ty</span>,)<span class="kw-2">*</span>],)<span class="op">*</span>
            },)<span class="op">*</span>

        },
        <span class="ident">items</span> <span class="op">=</span> [$({$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">items</span>: <span class="ident">tt</span>)<span class="kw-2">*</span>},)<span class="kw-2">*</span>],
        <span class="ident">rest</span> <span class="op">=</span> [$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">interface</span>: <span class="ident">ty</span>),<span class="op">+</span>]  $(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">rest</span>:<span class="ident">tt</span>)<span class="op">*</span>
    ) <span class="op">=&gt;</span> { ... };
    (
        @<span class="ident">parse_interfaces</span>,
        <span class="ident">success_callback</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">success_callback</span>: <span class="ident">ident</span>,
        <span class="ident">additional_parser</span> <span class="op">=</span> {$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">additional</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>},
        <span class="ident">meta</span> <span class="op">=</span> { $(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">meta</span>:<span class="ident">tt</span>)<span class="op">*</span> },
        <span class="ident">items</span> <span class="op">=</span> [$({$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">items</span>: <span class="ident">tt</span>)<span class="kw-2">*</span>},)<span class="kw-2">*</span>],
        <span class="ident">rest</span> <span class="op">=</span> <span class="ident">interfaces</span>: $(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">rest</span>:<span class="ident">tt</span>)<span class="op">*</span>
    ) <span class="op">=&gt;</span> { ... };
    (
        @<span class="ident">parse</span>,
        <span class="ident">meta</span> <span class="op">=</span> {$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">meta</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>},
        <span class="ident">rest</span> <span class="op">=</span> $(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">rest</span>:<span class="ident">tt</span>)<span class="op">*</span>
    ) <span class="op">=&gt;</span> { ... };
    (@$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">stuff</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>) <span class="op">=&gt;</span> { ... };
    (
        $(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">rest</span>:<span class="ident">tt</span>)<span class="op">*</span>
    ) <span class="op">=&gt;</span> { ... };
}</pre></div>
</div><div class='docblock'><p>Expose GraphQL objects</p>
<p>This is a short-hand macro that implements the <code>GraphQLType</code> trait for a given
type. By using this macro instead of implementing it manually, you gain type
safety and reduce repetitive declarations.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>The simplest case exposes fields on a struct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">User</span> { <span class="ident">id</span>: <span class="ident">String</span>, <span class="ident">name</span>: <span class="ident">String</span>, <span class="ident">group_ids</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span> }

<span class="macro">graphql_object</span><span class="macro">!</span>(<span class="ident">User</span>: () <span class="op">|</span><span class="kw-2">&amp;</span><span class="self">self</span><span class="op">|</span> {
    <span class="ident">field</span> <span class="ident">id</span>() <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="ident">String</span> {
        <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">id</span>
    }

    <span class="ident">field</span> <span class="ident">name</span>() <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="ident">String</span> {
        <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">name</span>
    }

    <span class="comment">// Field and argument names will be converted from snake case to camel case,</span>
    <span class="comment">// as is the common naming convention in GraphQL. The following field would</span>
    <span class="comment">// be named &quot;memberOfGroup&quot;, and the argument &quot;groupId&quot;.</span>
    <span class="ident">field</span> <span class="ident">member_of_group</span>(<span class="ident">group_id</span>: <span class="ident">String</span>) <span class="op">-&gt;</span> <span class="ident">bool</span> {
        <span class="self">self</span>.<span class="ident">group_ids</span>.<span class="ident">iter</span>().<span class="ident">any</span>(<span class="op">|</span><span class="ident">gid</span><span class="op">|</span> <span class="ident">gid</span> <span class="op">==</span> <span class="kw-2">&amp;</span><span class="ident">group_id</span>)
    }
});
</pre></div>
<h2 id="documentation-and-descriptions" class="section-header"><a href="#documentation-and-descriptions">Documentation and descriptions</a></h2>
<p>You can optionally add descriptions to the type itself, the fields,
and field arguments. For field and argument descriptions it is
possible to use normal rustdoc comments or doc
attributes. Alternatively the same syntax as for the type could be
used</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">User</span> { <span class="ident">id</span>: <span class="ident">String</span>, <span class="ident">name</span>: <span class="ident">String</span>, <span class="ident">group_ids</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span> }

<span class="macro">graphql_object</span><span class="macro">!</span>(<span class="ident">User</span>: () <span class="op">|</span><span class="kw-2">&amp;</span><span class="self">self</span><span class="op">|</span> {
    <span class="ident">description</span>: <span class="string">&quot;A user in the database&quot;</span>


    <span class="doccomment">/// The user&#39;s unique identifier</span>
    <span class="ident">field</span> <span class="ident">id</span>() <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="ident">String</span> {
        <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">id</span>
    }

    <span class="ident">field</span> <span class="ident">name</span>() <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="ident">String</span> <span class="kw">as</span> <span class="string">&quot;The user&#39;s name&quot;</span> {
        <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">name</span>
    }

    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Test if a user is member of a group&quot;</span>]</span>
    <span class="ident">field</span> <span class="ident">member_of_group</span>(
        <span class="doccomment">/// The group id you want to test membership against</span>
        <span class="doccomment">/// second line</span>
        <span class="ident">group_id</span>: <span class="ident">String</span>
    ) <span class="op">-&gt;</span> <span class="ident">bool</span> {
        <span class="self">self</span>.<span class="ident">group_ids</span>.<span class="ident">iter</span>().<span class="ident">any</span>(<span class="op">|</span><span class="ident">gid</span><span class="op">|</span> <span class="ident">gid</span> <span class="op">==</span> <span class="kw-2">&amp;</span><span class="ident">group_id</span>)
    }
});
</pre></div>
<h2 id="generics-and-lifetimes" class="section-header"><a href="#generics-and-lifetimes">Generics and lifetimes</a></h2>
<p>You can expose generic or pointer types by prefixing the type with the necessary
generic parameters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">trait</span> <span class="ident">SomeTrait</span> { <span class="kw">fn</span> <span class="ident">id</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="ident">str</span>; }

<span class="macro">graphql_object</span><span class="macro">!</span>(<span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">SomeTrait</span>: () <span class="kw">as</span> <span class="string">&quot;SomeTrait&quot;</span> <span class="op">|</span><span class="kw-2">&amp;</span><span class="self">self</span><span class="op">|</span> {
    <span class="ident">field</span> <span class="ident">id</span>() <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="ident">str</span> { <span class="self">self</span>.<span class="ident">id</span>() }
});

<span class="kw">struct</span> <span class="ident">GenericType</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> { <span class="ident">items</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> }

<span class="macro">graphql_object</span><span class="macro">!</span>(<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">GenericType</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>: () <span class="kw">as</span> <span class="string">&quot;GenericType&quot;</span> <span class="op">|</span><span class="kw-2">&amp;</span><span class="self">self</span><span class="op">|</span> {
    <span class="ident">field</span> <span class="ident">count</span>() <span class="op">-&gt;</span> <span class="ident">i32</span> { <span class="self">self</span>.<span class="ident">items</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">i32</span> }
});
</pre></div>
<h2 id="implementing-interfaces" class="section-header"><a href="#implementing-interfaces">Implementing interfaces</a></h2>
<p>You can use the <code>interfaces</code> item to implement interfaces:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">trait</span> <span class="ident">Interface</span> {
    <span class="kw">fn</span> <span class="ident">id</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="ident">str</span>;
    <span class="kw">fn</span> <span class="ident">as_implementor</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Implementor</span><span class="op">&gt;</span>;
}
<span class="kw">struct</span> <span class="ident">Implementor</span> { <span class="ident">id</span>: <span class="ident">String</span> }

<span class="macro">graphql_interface</span><span class="macro">!</span>(<span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Interface</span>: () <span class="kw">as</span> <span class="string">&quot;Interface&quot;</span> <span class="op">|</span><span class="kw-2">&amp;</span><span class="self">self</span><span class="op">|</span> {
    <span class="ident">field</span> <span class="ident">id</span>() <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="ident">str</span> { <span class="self">self</span>.<span class="ident">id</span>() }

    <span class="ident">instance_resolvers</span>: <span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">context</span><span class="op">|</span> {
        <span class="ident">Implementor</span> <span class="op">=&gt;</span> <span class="self">self</span>.<span class="ident">as_implementor</span>(),
    }
});

<span class="macro">graphql_object</span><span class="macro">!</span>(<span class="ident">Implementor</span>: () <span class="op">|</span><span class="kw-2">&amp;</span><span class="self">self</span><span class="op">|</span> {
    <span class="ident">field</span> <span class="ident">id</span>() <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="ident">str</span> { <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">id</span> }

    <span class="ident">interfaces</span>: [<span class="kw-2">&amp;</span><span class="ident">Interface</span>]
});
</pre></div>
<p>Note that the implementing type does not need to implement the trait on the Rust
side - only what's in the GraphQL schema matters. The GraphQL interface doesn't
even have to be backed by a trait!</p>
<h2 id="emitting-errors" class="section-header"><a href="#emitting-errors">Emitting errors</a></h2>
<p><code>FieldResult&lt;T, S = DefaultScalarValue&gt;</code> is a type alias for <code>Result&lt;T, FieldError&lt;S&gt;&gt;</code>, where
<code>FieldError</code> is a tuple that contains an error message and optionally a
JSON-like data structure. In the end, errors that fields emit are serialized
into strings in the response. However, the execution system will keep track of
the source of all errors, and will continue executing despite some fields
failing.</p>
<p>Anything that implements <code>std::fmt::Display</code> can be converted to a <code>FieldError</code>
automatically via the <code>?</code> operator, or you can construct them yourself using
<code>FieldError::new</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">User</span> { <span class="ident">id</span>: <span class="ident">String</span> }

<span class="macro">graphql_object</span><span class="macro">!</span>(<span class="ident">User</span>: () <span class="op">|</span><span class="kw-2">&amp;</span><span class="self">self</span><span class="op">|</span> {
    <span class="ident">field</span> <span class="ident">id</span>() <span class="op">-&gt;</span> <span class="ident">FieldResult</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">String</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">id</span>)
    }

    <span class="ident">field</span> <span class="ident">name</span>() <span class="op">-&gt;</span> <span class="ident">FieldResult</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">String</span><span class="op">&gt;</span> {
        <span class="prelude-val">Err</span>(<span class="string">&quot;Does not have a name&quot;</span>.<span class="ident">to_owned</span>())<span class="question-mark">?</span>
    }
});
</pre></div>
<h2 id="specify-scalar-value-representation" class="section-header"><a href="#specify-scalar-value-representation">Specify scalar value representation</a></h2>
<p>Sometimes it is necessary to use a other scalar value representation as the default
one provided by <code>DefaultScalarValue</code>.
It is possible to specify a specific scalar value type using the <code>where Scalar = Type</code>
syntax.
Additionally it is possible to use a generic parameter for the scalar value type
(in such a way that the type implements <code>GraphQLType</code> for all possible scalar value
representation). Similary to the specific type case the syntax here is
<code>where Scalar = &lt;S&gt;</code> where <code>S</code> is a freely choosable type parameter, that also could
be used as type parameter to the implementing type.</p>
<p>Example for using a generic scalar value type</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">User</span> { <span class="ident">id</span>: <span class="ident">String</span> }

<span class="macro">graphql_object</span><span class="macro">!</span>(<span class="ident">User</span>: () <span class="kw">where</span> <span class="ident">Scalar</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> <span class="op">|</span><span class="kw-2">&amp;</span><span class="self">self</span><span class="op">|</span> {
    <span class="ident">field</span> <span class="ident">id</span>() <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="ident">String</span> {
        <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">id</span>
    }

});
</pre></div>
<h1 id="syntax" class="section-header"><a href="#syntax">Syntax</a></h1>
<p>The top-most syntax of this macro defines which type to expose, the context
type, which lifetime parameters or generics to define,  which name to use in
the GraphQL schema and which scalar value type is used. It takes the
following form:</p>
<pre><code class="language-text">&lt;Generics&gt; ExposedType: ContextType as &quot;ExposedName&quot; where Scalar = &lt;S&gt; |&amp;self| { items... }
&lt;Generics&gt; ExposedType: ContextType as &quot;ExposedName&quot; where Scalar = SpecificType |&amp;self| { items... }
</code></pre>
<p>The following parts are optional:</p>
<ul>
<li><code>&lt;Generics&gt;</code>, if not set no generics are defined</li>
<li><code>as &quot;ExposedName&quot;</code>, if not set <code>ExposedType</code> is used as name</li>
<li><code>where Scalar = &lt;S&gt;</code> / <code>where Scalar = SpecificType</code> if not set <code>DefaultScalarValue</code>
is used as scalar value</li>
</ul>
<h2 id="items" class="section-header"><a href="#items">Items</a></h2>
<p>Each item within the brackets of the top level declaration has its own syntax.
The order of individual items does not matter. <code>graphql_object!</code> supports a
number of different items.</p>
<h3 id="top-level-description" class="section-header"><a href="#top-level-description">Top-level description</a></h3>
<pre><code class="language-text">description: &quot;Top level description&quot;
</code></pre>
<p>Adds documentation to the type in the schema, usable by tools such as GraphiQL.</p>
<h3 id="interfaces" class="section-header"><a href="#interfaces">Interfaces</a></h3>
<pre><code class="language-text">interfaces: [&amp;Interface, ...]
</code></pre>
<p>Informs the schema that the type implements the specified interfaces. This needs
to be <em>GraphQL</em> interfaces, not necessarily Rust traits. The Rust types do not
need to have any connection, only what's exposed in the schema matters.</p>
<h3 id="fields" class="section-header"><a href="#fields">Fields</a></h3>
<pre><code class="language-text">field name(args...) -&gt; Type { }
field name(args...) -&gt; Type as &quot;Field description&quot; { }
field deprecated &quot;Reason&quot; name(args...) -&gt; Type { }
field deprecated &quot;Reason&quot; name(args...) -&gt; Type as &quot;Field description&quot; { }
</code></pre>
<p>Defines a field on the object. The name is converted to camel case, e.g.
<code>user_name</code> is exposed as <code>userName</code>. The <code>as &quot;Field description&quot;</code> adds the
string as documentation on the field.</p>
<p>A field's description and deprecation can also be set using the
builtin <code>doc</code> and <code>deprecated</code> attributes.</p>
<pre><code class="language-text">/// Field description
field name(args...) -&gt; Type { }

#[doc = &quot;Field description&quot;]
field name(args...) -&gt; Type {}

#[deprecated] // no reason required
field name(args...) -&gt; Type { }

#[deprecated(note = &quot;Reason&quot;)]
field name(args...) -&gt; Type { }

/// Field description
#[deprecated(note = &quot;Reason&quot;)] // deprecated must come after doc
field deprecated &quot;Reason&quot; name(args...) -&gt; Type { }
</code></pre>
<h3 id="field-arguments" class="section-header"><a href="#field-arguments">Field arguments</a></h3>
<pre><code class="language-text">&amp;executor
arg_name: ArgType
arg_name = default_value: ArgType
arg_name: ArgType as &quot;Argument description&quot;
arg_name = default_value: ArgType as &quot;Argument description&quot;
</code></pre>
<p>Field arguments can take many forms. If the field needs access to the executor
or context, it can take an <a href="struct.Executor.html">Executor</a> instance by specifying <code>&amp;executor</code>
as the first argument.</p>
<p>The other cases are similar to regular Rust arguments, with two additions:
argument documentation can be added by appending <code>as &quot;Description&quot;</code> after the
type, and a default value can be specified by appending <code>= value</code> after the
argument name.</p>
<p>Arguments are required (i.e. non-nullable) by default. If you specify <em>either</em> a
default value, <em>or</em> make the type into an <code>Option&lt;&gt;</code>, the argument becomes
optional. For example:</p>
<pre><code class="language-text">arg_name: i32               -- required
arg_name: Option&lt;i32&gt;       -- optional, None if unspecified
arg_name = 123: i32         -- optional, &quot;123&quot; if unspecified
</code></pre>
<p>Due to some syntactical limitations in the macros, you must parentesize more
complex default value expressions:</p>
<pre><code class="language-text">arg_name = (Point { x: 1, y: 2 }): Point
arg_name = (&quot;default&quot;.to_owned()): String
</code></pre>
<p>A description can also be provided using normal doc comments or doc attributes.</p>
<pre><code class="language-text">/// Argument description
arg_name: ArgType
#[doc = &quot;Argument description&quot;]
arg_name: ArgType
</code></pre>
</div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "juniper";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>